#pragma version ^0.2.0;

;; Storage Variables
global int reserve0;
global int reserve1;
global int total_supply;
global cell lp_wallets;

;; Constants
const int DECIMAL_FACTOR = 1000000000;  ;; 10^9
const int MIN_LIQUIDITY = 1000;         ;; Min liquidity
const int FEE_DENOMINATOR = 1000;       ;; Fee denominator
const int FEE_NUMERATOR = 3;            ;; 0.3% fee

;; Error codes
const int error_unauthorized = 101;
const int error_insufficient_liquidity = 102;
const int error_insufficient_amount = 103;
const int error_slippage_too_high = 104;

;; Operation codes
const int op_swap = 1;
const int op_add_liquidity = 2;
const int op_remove_liquidity = 3;
const int op_transfer = 4;

() load_data() impure {
    slice ds = get_data().begin_parse();
    reserve0 = ds~load_coins();
    reserve1 = ds~load_coins();
    total_supply = ds~load_coins();
    lp_wallets = ds~load_dict();
}

() save_data() impure {
    set_data(begin_cell()
        .store_coins(reserve0)
        .store_coins(reserve1)
        .store_coins(total_supply)
        .store_dict(lp_wallets)
        .end_cell());
}

int min(int x, int y) inline {
    if (x > y) { return y; }
    return x;
}

int get_lp_balance(slice addr) inline {
    (cell balance_cell, int found) = lp_wallets.udict_get?(267, slice_hash(addr));
    if (found) {
        return balance_cell.begin_parse().preload_coins();
    }
    return 0;
}

() set_lp_balance(slice addr, int amount) impure inline {
    lp_wallets~udict_set(267, slice_hash(addr),
        begin_cell().store_coins(amount).end_cell());
}

int calculate_out_amount(int amount_in) inline {
    int amount_with_fee = (amount_in * (FEE_DENOMINATOR - FEE_NUMERATOR));
    return muldiv(amount_with_fee, reserve1, reserve0 * FEE_DENOMINATOR + amount_with_fee);
}

() handle_swap(slice msg) impure {
    int min_out = msg~load_coins();
    int amount_in = msg~load_coins();
    slice sender = msg~load_msg_addr();

    throw_if(error_insufficient_amount, amount_in < MIN_LIQUIDITY);

    ;; Calculate output amount
    int amount_out = calculate_out_amount(amount_in);
    throw_if(error_slippage_too_high, amount_out < min_out);

    ;; Update reserves
    reserve0 += amount_in;
    reserve1 -= amount_out;

    ;; Send output tokens
    send_raw_message(begin_cell()
        .store_uint(0x18, 6)
        .store_slice(sender)
        .store_coins(amount_out)
        .store_uint(0, 107)
        .store_uint(op_transfer, 32)
        .end_cell(), 64);
}

() handle_add_liquidity(slice msg) impure {
    int amount0 = msg~load_coins();
    int amount1 = msg~load_coins();
    slice provider = msg~load_msg_addr();

    ;; Calculate liquidity to mint
    int liquidity = 0;
    if (total_supply == 0) {
        liquidity = min(amount0, amount1) - MIN_LIQUIDITY;
        set_lp_balance(my_address(), MIN_LIQUIDITY);
    } else {
        liquidity = min(
            muldiv(amount0, total_supply, reserve0),
            muldiv(amount1, total_supply, reserve1)
        );
    }

    throw_if(error_insufficient_liquidity, liquidity <= 0);

    ;; Update state
    reserve0 += amount0;
    reserve1 += amount1;
    total_supply += liquidity;

    ;; Update LP tokens
    int current_lp = get_lp_balance(provider);
    set_lp_balance(provider, current_lp + liquidity);
}

;; Get methods
(int, int) get_reserves() method_id {
    load_data();
    return (reserve0, reserve1);
}

int get_lp_tokens(slice addr) method_id {
    load_data();
    return get_lp_balance(addr);
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { return (); }

    slice cs = in_msg_full.begin_parse();
    cs~load_uint(4);
    slice sender = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);

    load_data();

    if (op == op_swap) {
        handle_swap(in_msg_body);
    } elseif (op == op_add_liquidity) {
        handle_add_liquidity(in_msg_body);
    }

    save_data();
}